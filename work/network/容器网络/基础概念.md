#### netns

ip netns delete只是移除挂载点，只要里面的进程没有被删除就不会被删除

通过mount 一个文件到对应的ns下面就可以保持ns一直存在（文件一直open）

clone():创建出一个新的进程

setns():往ns里面添加进程

unshare(): 创建新的ns并将现有的进程放进去

#### veth

- 当veth的一端veth1绑定到bridge的时候，veth1和协议栈的一端就变成单向通信（只能由协议栈发向veth1）
    
- bridge会和veth进行双向通信，并且bridge的mac地址会变成veth1的mac地址
    
- 会导致从veth1 ping veth2收不到arp回包（回包给了bridge）
    

#### Tun(L3)/Tap(L2)设备

1. 和物理网卡的区别：数据源不是物理链路而是来自用户态
    
2. 利用Linux的设备文件实现内核态和用户态的交互
    
    1. 在内核模块中创建设备文件：使用cdev机制注册字符设备，并将其与内核模块的功能函数关联
        
    2. 在用户空间打开读写设备文件（像操作普通文件一样打开设备文件）
        
3. 主要用途：将内核中协议栈的部分数据包转发给用户空间的应用程序，给用户空间一个处理数据包的机会
    
4. tun设备是通过打开/dev/net/tun进行启动，主要是提供一种内核网络和用户空间通信机制
    
5. 应用可以直接读写tun设备的方式收发RAW IP包
    
    1. 打开tun设备，使用 open() 系统调用打开 /dev/net/tun
        
    2. 配置tun设备，使用 ioctl() 系统调用配置tun设备，也可绑定一个虚拟网络接口
        
    3. 读写IP包，使用read() 从tun设备读取原始IP包，使用write()向tun设备写入原始IP包
        
    4. 关闭tun设备，使用close()系统调用关闭tun设备
        

VPN的实现：

- app1的数据在发往协议栈之后，协议栈会转发给tun0设备
    
- 协议栈根据数据包的目的地址查找路由表或策略路由规则。
    
- 为什么转给tun0设备，因为在vpn设备启动后会强制写默认路由或者其它方式让所有数据包的目的地址变成tun0设备
    
- tun0设备接受到协议栈的数据包之后再转发给用户态的vpn用户态的对端设备，经过处理之后再发给--》协议栈--》网卡 发出去
    

#### iptables

5链

- PreRouting(DNAT) ：raw,mangle,nat
    
- PostRouting(SNAT): mangle, nat
    
- Input(SNAT) : mangle,nat,filter,security
    
- Output(DNAT): raw, mangle,nat,filter,security
    
- Forward(Reject): mangle, filter,security
    

5表相关规则，优先级依次：

1. Raw: 去除状态跟踪 prerouting,output
    
2. Mangle: 修改ip头部信息，所有都可以
    
3. Nat: 地址转换
    
    1. 输入都是DNAT
        
    2. 输出都是SNAT
        
4. Filter : 控制某条链的数据包是否放行还是丢弃，拒绝
    
5. Security: 数据包应用在SE Linux
    

#### vxlan

1. 为什么需要vxlan
    
    1. 能突破vlan的最多4096的子网数量
        
    2. vxlan的报文header内有24bit，并通过VNI区分不同的子网，相当于VLAN中的LAN ID
        
    3. 多租户隔离（通过VNI识别不同的vxlan网络）
        
2. vxlan工作模型
    
    1. 三层可达
        
    2. vxlan网络的每个端点都有一个vtep设备
        
    3. vtep可以是一个网络设备（交换机），也可以是一台机器
        
    4. mac in UDP,在三层网络的基础上构建一个虚拟的二层网络